


server:
  port: 8080
spring:
  application:
    name: "accounts"
  profiles:
    active: "prod"
  datasource:
    url: jdbc:h2:mem:./data/testdb
    driverClassName: org.h2.Driver
    username: sa
    password: ''
  h2:
   console:
    enabled: true
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
     ddl-auto: update
    show-sql: true


  config:
    import: "optional:configserver:http://localhost:8071/"


  rabbitmq:
    host: "localhost"
    port: 5672
    username: "guest"
    password: "guest"

  cloud:   # to enable circuit breaker for openfeign clients
    openfeign:
      circuitbreaker:
        enabled: true

management:
  endpoints:
    web:
      exposure:
        include: "*"
  health:
    readiness-state:
      enabled: true
    liveness-state:
      enabled: true
  endpoint: # enabling shutdown endpoint to gracefully shutdown the application using shutdown actuator path to test de-registering from eureka server
    shutdown:
      access: unrestricted
    health:
      probes:
        enabled: true
  info:   # enabling info endpoint
    env:
      enabled: true
  metrics: # to regroup all the metrics under one tag(application name) in prometheus, otherwise we will know for each microservice the metrics realeted to it
    tags:
      application: ${spring.application.name}

# testing the refresh configurations at runtime using refresh actuator path, the same is in all microservices



eureka:   # for connecting to eureka server
  instance:
    preferIpAddress: true
  client:
    fetchRegistry: true
    registerWithEureka: true
    serviceUrl:
      defaultZone: http://localhost:8070/eureka/

info:  # info endpoint data at /actuator/info (this path is unabled so that's why we will make some changes in the section management related to actuator), it will be visible in eureka server that's why we are using it
  app:
    name: "accounts"
    description: "myBank Accounts Application"
    version: "3.0.0"


springdoc:
  swagger-ui:
    path: /docs

logging:  # enable logs generated by logging framework with type(level) Debug
  level:
    com:
      mybank:
        accounts: DEBUG

resilience4j.circuitbreaker:   # already explained in datewayserver's application.yml
  configs:
    default:
      slidingWindowSize: 10
      permittedNumberOfCallsInHalfOpenState: 2
      failureRateThreshold: 50
      waitDurationInOpenState: 10000

resilience4j.retry:
  configs:
    default:
      maxAttempts: 3
      waitDuration: 100
      enableExponentialBackoff: true
      exponentialBackoffMultiplier: 2
      ignoreExceptions:  # with this we can ignore some exceptions from retry mechanism,but always the value of fallback method will be executed and returned, just the mecanism of retry will not be executed when these exceptions are thrown
        - java.lang.RuntimeException
      retryExceptions: # with this we can specify which exceptions will be considered for retry mechanism
        - java.util.concurrent.TimeoutException

resilience4j.ratelimiter:
  configs:  # the configuration inside a spring microservice is deffirent from the configuration in api-gateway microservice. the conf here is for all users of the microservice
    default:  # explanation of the example : in every 5 seconds only 1 call will be allowed, if more calls are made in this period of time then the fallback method will be executed
      timeoutDuration: 1000  # explaination : the time a thread should wait for permission ms
      limitRefreshPeriod: 5000 # explaination : the period of time after which the rate limiter limit will be refreshed ms
      limitForPeriod: 1 # explaination : the number of calls that can be made in the limitRefreshPeriod